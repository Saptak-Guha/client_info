In summary, the “hardcoded” pieces are:
Sample reviews (the ten reviews and ratings for your own product).

Market products (names A/B/C/D, with hardcoded avg_rating/price/units_sold).

Review counts array ([120, 85, 180, 110]) for those market products.

Our product’s price (69.99) and units_sold (600) inside our_metrics.

“Key Findings” bullets (except the interpolated rank), which never change.

“Improvement Areas” list (four fixed issue statements).

“Strategic Recommendations” list (five fixed action items).

All static template labels/icons/headers in dashboard.html.



perf.csv
value_score = avg_rating / (price / 10)
feature_gap_score = missing_features / total_desired_features
 
sentiment_analysis to be done using NLTK Vader.




APP.py
# app.py
from flask import Flask, render_template, send_file
import pandas as pd
import numpy as np
from nltk.sentiment import SentimentIntensityAnalyzer
from xgboost import XGBRegressor
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
from io import BytesIO
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib import colors
import seaborn as sns
import base64
import nltk
from datetime import datetime
# Download required NLTK data
nltk.download('vader_lexicon')

app = Flask(__name__)

# Sample data generation
def generate_sample_data():
    # Our product data
    our_product_reviews = [
        {"review": "This product is amazing! Works perfectly.", "rating": 5},
        {"review": "Decent product but could be better", "rating": 3},
        {"review": "Terrible experience, broke after 2 days", "rating": 1},
        {"review": "Good value for money", "rating": 4},
        {"review": "Not what I expected, poor quality", "rating": 2},
        {"review": "Absolutely love it! Best purchase ever.", "rating": 5},
        {"review": "Mediocre performance, average product", "rating": 3},
        {"review": "Worst product I've ever bought", "rating": 1},
        {"review": "Exceeds expectations", "rating": 5},
        {"review": "Okay but not worth the price", "rating": 2}
    ]
    
    # Market products data
    market_products = [
        {"product": "Product A", "avg_rating": 4.2, "price": 49.99, "units_sold": 1200},
        {"product": "Product B", "avg_rating": 3.8, "price": 59.99, "units_sold": 800},
        {"product": "Product C", "avg_rating": 4.5, "price": 79.99, "units_sold": 1500},
        {"product": "Product D", "avg_rating": 4.0, "price": 54.99, "units_sold": 950}
    ]
    
    return pd.DataFrame(our_product_reviews), pd.DataFrame(market_products)

# Sentiment analysis with VADER
def analyze_sentiment(reviews_df):
    sia = SentimentIntensityAnalyzer()
    reviews_df['sentiment'] = reviews_df['review'].apply(lambda x: sia.polarity_scores(x)['compound']) 
    reviews_df['sentiment_category'] = reviews_df['sentiment'].apply(
        lambda x: 'Positive' if x > 0.05 else 'Negative' if x < -0.05 else 'Neutral'
    )
    return reviews_df

# Feature engineering and XGBoost ranking
def calculate_product_rankings(our_reviews, market_df):
    # Sentiment analysis
    our_reviews = analyze_sentiment(our_reviews)
    
    # Calculate our product metrics
    our_metrics = {
        'product': 'Our Product',
        'avg_rating': our_reviews['rating'].mean(),
        'avg_sentiment': our_reviews['sentiment'].mean(),
        'positive_pct': (our_reviews['sentiment_category'] == 'Positive').mean() * 100,
        'review_count': len(our_reviews),
        'price': 69.99,  # Added price for our product
        'units_sold': 600  # Added units sold for our product
    }
    
    # Prepare data for ranking model
    ranking_data = market_df.copy()
    # Add review counts for market products (sample data)
    review_counts = [120, 85, 180, 110]
    ranking_data['review_count'] = review_counts[:len(ranking_data)]
    
    # Add our product to the ranking data
    ranking_data = pd.concat([ranking_data, pd.DataFrame([our_metrics])], ignore_index=True)
    
    # Feature engineering
    ranking_data['value_score'] = ranking_data.apply(
        lambda row: row['avg_rating'] / (row['price'] / 10) if row['price'] != 0 else 0, axis=1
    )
    ranking_data['popularity'] = ranking_data['units_sold'] * ranking_data['avg_rating']
    
    noise = np.clip(np.random.normal(0, 50, len(ranking_data)), -100, 100)
    ranking_data['sales_velocity'] = ranking_data['units_sold'] * ranking_data['avg_rating'] * 0.8 + noise

    # Clean target variable
    ranking_data = ranking_data.dropna(subset=['sales_velocity'])  # Remove rows where target is NaN or Inf
    ranking_data = ranking_data[np.isfinite(ranking_data['sales_velocity'])]  # Remove inf or -inf
    
    # Train XGBoost model
    X = ranking_data[['avg_rating', 'price', 'units_sold', 'review_count', 'value_score', 'popularity']]
    y = ranking_data['sales_velocity']
    
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    
    model = XGBRegressor(objective='reg:squarederror', n_estimators=100, random_state=42)
    model.fit(X_train, y_train)
    
    # Predict and rank
    ranking_data['rank_score'] = model.predict(X)
    ranking_data['rank'] = ranking_data['rank_score'].rank(ascending=False).astype(int)
    ranking_data = ranking_data.sort_values('rank')
    
    return ranking_data, our_reviews

# Generate PDF report
def generate_pdf_report(ranking_data, our_reviews, market_df):
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=letter)
    styles = getSampleStyleSheet()
    elements = []
    
    # Title
    title_style = ParagraphStyle(
        'Title',
        parent=styles['Heading1'],
        alignment=1,
        spaceAfter=14
    )
    elements.append(Paragraph("Product Performance Analysis Report", title_style))
    
    # Summary
    elements.append(Paragraph("Executive Summary", styles['Heading2']))
    summary_text = "This report analyzes our product's performance relative to key competitors in the market. " \
                  "The analysis combines sentiment analysis of customer reviews with quantitative metrics " \
                  "to provide a comprehensive ranking and identify improvement opportunities."
    elements.append(Paragraph(summary_text, styles['BodyText']))
    elements.append(Spacer(1, 12))
    
    # Key Findings
    elements.append(Paragraph("Key Findings", styles['Heading2']))
    our_rank = ranking_data[ranking_data['product'] == 'Our Product']['rank'].values[0]
    total_products = len(ranking_data)
    
    findings = [
        f"- Our product is currently ranked #{our_rank} out of {total_products} market products",
        "- Sentiment analysis shows room for improvement in customer satisfaction",
        "- Competitor analysis reveals strengths in Product C and Product A",
        "- Pricing strategy should be reviewed based on value score comparison"
    ]
    
    for item in findings:
        elements.append(Paragraph(item, styles['BodyText']))
    elements.append(Spacer(1, 12))
    
    # Market Ranking Table
    elements.append(Paragraph("Market Product Ranking", styles['Heading2']))
    
    # Prepare table data
    table_data = [['Rank', 'Product', 'Avg Rating', 'Price', 'Units Sold', 'Rank Score']]
    for _, row in ranking_data.iterrows():
        table_data.append([
            int(row['rank']),
            row['product'],
            f"{row['avg_rating']:.1f}",
            f"${row['price']:.2f}",
            int(row['units_sold']),
            f"{row['rank_score']:.1f}"
        ])
    
    # Create table
    table = Table(table_data)
    table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.lightblue),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.black),
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 10),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('GRID', (0, 0), (-1, -1), 1, colors.black)
    ]))
    elements.append(table)
    elements.append(Spacer(1, 20))
    
    # Sentiment Analysis
    elements.append(Paragraph("Our Product: Sentiment Analysis", styles['Heading2']))
    sentiment_counts = our_reviews['sentiment_category'].value_counts()
    
    # Create pie chart
    plt.figure(figsize=(6, 4))
    plt.pie(sentiment_counts, labels=sentiment_counts.index, autopct='%1.1f%%', 
            colors=['#4CAF50', '#FFC107', '#F44336'])
    plt.title('Customer Sentiment Distribution')
    img_buf = BytesIO()
    plt.savefig(img_buf, format='png', bbox_inches='tight')
    img_buf.seek(0)
    img_data = base64.b64encode(img_buf.read()).decode()
    plt.close()
    
    # Add image to PDF
    elements.append(Image(BytesIO(base64.b64decode(img_data)), width=400, height=300))
    elements.append(Spacer(1, 12))
    
    # Improvement Areas
    elements.append(Paragraph("Key Improvement Areas", styles['Heading2']))
    
    issues = [
        "1. Quality Concerns: Multiple reviews mention durability issues",
        "2. Value Perception: Customers feel the price doesn't match the quality",
        "3. Feature Gap: Lacks key features offered by competitors",
        "4. Inconsistent Experience: Quality varies between units"
    ]
    
    for issue in issues:
        elements.append(Paragraph(issue, styles['BodyText']))
    elements.append(Spacer(1, 12))
    
    # Recommendations
    elements.append(Paragraph("Strategic Recommendations", styles['Heading2']))
    
    recommendations = [
        "• Conduct quality control audit on manufacturing process",
        "• Re-evaluate pricing strategy based on competitor analysis",
        "• Develop product roadmap to address feature gaps",
        "• Implement customer satisfaction program with follow-up surveys",
        "• Create competitive upgrade program to attract customers from Product A and C"
    ]
    
    for rec in recommendations:
        elements.append(Paragraph(rec, styles['BodyText']))
    
    # Build PDF
    doc.build(elements)
    buffer.seek(0)
    return buffer

# Generate visualizations
def generate_visualizations(ranking_data, our_reviews):
    visuals = {}
    
    # Market ranking bar chart
    plt.figure(figsize=(10, 6))
    ranked_products = ranking_data.sort_values('rank_score', ascending=False)
    sns.barplot(x='rank_score', y='product', data=ranked_products, palette='viridis')
    plt.title('Product Ranking in Market')
    plt.xlabel('Rank Score')
    plt.ylabel('Product')
    buf = BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    buf.seek(0)
    visuals['ranking_chart'] = base64.b64encode(buf.read()).decode('utf-8')
    plt.close()
    
    # Sentiment distribution
    plt.figure(figsize=(8, 6))
    sentiment_counts = our_reviews['sentiment_category'].value_counts()
    sns.barplot(x=sentiment_counts.index, y=sentiment_counts.values, palette='pastel')
    plt.title('Customer Sentiment Distribution')
    plt.xlabel('Sentiment')
    plt.ylabel('Count')
    buf = BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    buf.seek(0)
    visuals['sentiment_chart'] = base64.b64encode(buf.read()).decode('utf-8')
    plt.close()
    
    # Rating vs sentiment scatter
    plt.figure(figsize=(8, 6))
    sns.scatterplot(x='rating', y='sentiment', data=our_reviews, hue='sentiment_category', palette='Set2', s=100)
    plt.title('Rating vs Sentiment Correlation')
    plt.xlabel('Rating (1-5)')
    plt.ylabel('Sentiment Score')
    plt.axhline(y=0, color='gray', linestyle='--')
    buf = BytesIO()
    plt.savefig(buf, format='png', bbox_inches='tight')
    buf.seek(0)
    visuals['scatter_chart'] = base64.b64encode(buf.read()).decode('utf-8')
    plt.close()
    
    return visuals

@app.route('/')
def dashboard():
    # 1) Load sample data
    our_reviews, market_df = generate_sample_data()
    
    # 2) Calculate rankings & sentiment
    ranking_data, analyzed_reviews = calculate_product_rankings(our_reviews, market_df)
    
    # 3) Extract our product row and convert to dict
    our_product_row = ranking_data[ranking_data['product'] == 'Our Product'].iloc[0]
    our_product_data = our_product_row.to_dict()  # <— convert Series → dict
    
    # 4) Prepare market_ranking as list of dicts
    market_ranking = ranking_data[['rank', 'product', 'avg_rating', 'price', 'units_sold', 'rank_score']
                     ].to_dict('records')
    
    # 5) Top negative reviews
    negative_reviews = (
        analyzed_reviews[analyzed_reviews['sentiment_category'] == 'Negative']
        .sort_values('sentiment')
        .head(3)
    ).to_dict('records')
    
    # 6) Visualizations
    visuals = generate_visualizations(ranking_data, analyzed_reviews)
    
    # 7) Compute market share
    total_units = sum(item['units_sold'] for item in market_ranking)
    market_share = (our_product_data['units_sold'] / total_units * 100) if total_units > 0 else 0
    
    # 8) Pass a `now` timestamp for the footer
    now = datetime.now()
    
    return render_template(
        'dashboard.html',
        our_product=our_product_data,
        market_ranking=market_ranking,
        negative_reviews=negative_reviews,
        visuals=visuals,
        market_share=market_share,
        total_units=total_units,
        now=now,  # <— pass now into the template
    )
@app.route('/download_report')
def download_report():
    # Load sample data
    our_reviews, market_df = generate_sample_data()
    
    # Calculate rankings
    ranking_data, analyzed_reviews = calculate_product_rankings(our_reviews, market_df)
    
    # Generate PDF
    pdf_buffer = generate_pdf_report(ranking_data, analyzed_reviews, market_df)
    
    return send_file(
        pdf_buffer,
        as_attachment=True,
        download_name='Product_Performance_Report.pdf',
        mimetype='application/pdf'
    )

if __name__ == '__main__':
    app.run(debug=True)
